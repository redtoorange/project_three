-- Name: Andrew McGuiness
-- Date: October 21, 2017
-- Course: ITEC 320 Procedural Analysis and Design
--
-- package body for the Commands package
--
-- Purpose: The primary purpose of the commands Package is to simplify the main
--    procedure.  The program and be in one of two states, the second state is
--    a command driven interactive state which is handled by the Commands
--    package.

package body Commands is

   -- Public Subroutines ---------------------------------------------------------

   -- Process_Commands ------------------------------------------------------
   procedure Process_Commands (tl : in Tree_List) is
   -- Custom input package to handle our command input.
      package Command_IO is new Enumeration_IO (Command);
      use Command_IO;
      c_command : Command;
   begin
      -- Continue looping until the user enters "QUIT" or we hit an EoF.
      Processing_Input :
      loop
         begin
            Get (c_command);

            -- Execute a command based on our input
            case c_command is
               when TREES =>
                  Trees_Command (tl);
               when FRUITS =>
                  Fruits_Command (tl);
               when AVERAGES =>
                  Averages_Command (tl);
               when QUIT =>
                  exit Processing_Input;
            end case;

         exception
            when End_Error =>
               -- Would typically happen if a command file was piped in.
               Put_Line ("End of File Reached.");
               exit Processing_Input;

               when Data_Error =>
               -- User put in a bad command, trash it and move on.
               Put_Line ("Invalid Command.");
               Skip_Line;

            when e : others =>
               -- This is probably fatal, just leave.
               Put_Line (Exception_Name (e) & ": " & Exception_Message (e));
               exit Processing_Input;
         end;
      end loop Processing_Input;
   end Process_Commands;

   -- Private Subroutines --------------------------------------------------------

   -- Trees_Command ---------------------------------------------------------
   procedure Trees_Command (tl : in Tree_List) is
   begin
      for t in 1 .. tl.t_count loop
         -- Put the Tree's ID and Fruit Count
         Put_Tree (tl.trees (t));
         New_Line;
      end loop;
   end Trees_Command;

   -- Fruits_Command --------------------------------------------------------
   procedure Fruits_Command (tl : in Tree_List) is
   begin
      for t in 1 .. tl.t_count loop
         -- Put the Tree's ID and Fruit Count
         Put_Tree (tl.trees (t));
         Put (":");
         New_Line;

         -- Print the Tree's Fruit
         for f in 1 .. tl.trees (t).f_count loop
            Put_Fruit (tl.trees (t).fruits (f));
            New_Line;
         end loop;

         -- Print the Tree's Stats
         Put_Tree_Stats (tl.trees (t).f_stats);
         New_Line;
      end loop;
   end Fruits_Command;

   -- Averages_Command ------------------------------------------------------
   procedure Averages_Command (tl : in Tree_List) is
   begin
      for t in 1 .. tl.t_count loop
         -- Put the Tree's ID and Fruit Count
         Put_Tree (tl.trees (t));
         Put (":");

         New_Line;

         -- Print the Tree's Stats
         Put_Tree_Stats (tl.trees (t).f_stats);
         New_Line;
      end loop;
   end Averages_Command;

end Commands;
